---
sidebar_position: 2
---

# Implementing the first API

In this section, we will experience a quick implementation of an API service using TSRPC and call it in the browser.

The full example of this section is available at: https://github.com/k8w/tsrpc-examples/tree/main/examples/first-api

## Initializing the project

We start by initializing a Web full-stack project.

```
npx create-tsrpc-app@latest first-api --presets browser
```

Then we delete the self-contained demo code, i.e. empty the following directories.

- ` backend/src/shared/protocols`
- `backend/src/api`

## Concepts

Before developing API interfaces using TSRPC, it is important to understand a few important concepts.

- **API**
  - An API interface is equivalent to an asynchronous function implemented on the remote end. The input parameters of this function are called **Request** and the return value is called **Response**.
- **Protocol**
  - The protocol is the type definition of the API interface, including its request type and response type, and can also contain other configuration information about the interface (e.g. whether login authentication is required, etc.).
- **API Implementation**
  - The implementation is the code that implements the functionality of the API interface.
- **Server**
  - The implementation side of the API interface, NodeJS 12 or higher.
- **Client**
  - The calling end of the API interface, supporting multiple platforms, such as: browser, APP, WeChat applet, NodeJS, etc.

So to implement a backend API interface, only 3 steps are needed.
**define protocol -> server-side implementation -> client-side invocation**.

:::note
The reason TSRPC separates the protocol and implementation of the API is that the protocol part can be used by both front and back ends and can be shared across projects, while the implementation obviously exists only on the NodeJS server side.
:::

## Define the protocol

### Writing protocol files

The protocols directory is located in the `backend/src/shared/protocols` directory by default, and protocol files are named `Ptl{interface name}.ts`.

For example, if we want to implement a protocol named `Hello`, create the file `PtlHello.ts` in that directory and define the request type `ReqHello` and the response type `ResHello` respectively, remembering to export them with the `export` tag.

```ts
export interface ReqHello {
  name: string
}

export interface ResHello {
  reply: string
  time: Date
}
```

:::tip
TSRPC identifies the protocol (Ptl), request (Req), and response (Res) by name prefix, so be sure to name them as specified.
:::

### Generate ServiceProto

[`ServiceProto`](... /server/service-proto.md) is the actual protocol format used by the TSRPC runtime and is automatically generated by executing the following command.

```shell
cd backend
npm run proto
```

:::tip
This command should be run whenever the protocol is modified to regenerate it.
:::

## Implementing the API

### Creating implementation files

TSRPC's API interface implementation is separate from the protocol definition because the protocol definition contains type information that can be shared across projects, while the implementation part can obviously only run on the NodeJS server.
To differentiate, protocol definitions are named `Ptl{interface name}.ts` and implementations are prefixed with `Api{interface name}.ts`.

The interface implementation is located in `backend/src/api`, which corresponds to the protocol definition, and the prefix of the file name is replaced by `Api` instead of `Ptl`. We've prepared the tools for you to generate it automatically, just follow the previous step with.

```shell
npm run api
```

This way, a blank API file is automatically generated. For the protocol we just defined `PtlHello.ts`, the corresponding generated implementation file is named `ApiHello.ts` and the directory structure is as follows.

````
|- backend/src
    |- shared/protocols
        |- PtlHello.ts definition of the interface Hello
    |- api
        |- ApiHello.ts implementation of the interface Hello
    |- index.ts
index.ts

:::tip
Existing API files are not overwritten or deleted and can be generated incrementally at any time.
:::

### Requests and responses
The implementation of the API is an asynchronous function, and input and output to the client is done via the passed-in parameter `call`.
- The request parameter, `ReqHello` as defined in the protocol, is retrieved via `call.req`, where the framework ensures that the type **must be legal**.
- Return the response via `call.succ(res)`, i.e. `ResHello` as defined in the protocol.
- The error is returned via `call.error('readable error message', { xxx: 'xxx' })`, with the second parameter being an optional extra field that you want to return.

For example.

```ts title="backend/src/api/ApiHello.ts"
import { ApiCall } from "tsrpc";

export async function ApiHello(call: ApiCall<ReqHello, ResHello>) {
    if(call.req.name === 'World'){
        call.succ({
            reply: 'Hello, ' + call.req.name,
            time: new Date()
        });
    }
    else{
        call.error('Invalid name');
    }
}
````

## Calling the API

### Shared code

To invoke the API, the client must have the same protocol definition file, and there may be other common logic code that can be reused on the front and back ends in addition.
For this purpose, we designed the `src/shared` directory. The contents of this directory are always edited in `backend` and then read-only synchronized to `frontend`.

Execute the following command to complete the synchronization.

```shell
cd backend
npm run sync
```

:::note
The `shared` directory is read-only on the frontend to prevent changes on the frontend from being overwritten by syncing on the backend. If you want to securely modify the contents of the `shared` directory on the frontend as well, you can choose the `Symlink` auto-sync method.
:::

### Using the client

Use the TSRPC client to call remote APIs as if they were local asynchronous functions, with full code hinting and type detection.
It supports many platforms, and can be written from different NPM packages `import { HttpClient }` as needed, the rest is the same.

| client platform | NPM package |
| :-------------: | :---------: |
|  tsrpc-browser  |
|  tsrpc-miniapp  |
|     NodeJS      |    tsrpc    |

Since we are creating a browser web project, we are referring to the browser version of the client from `tsrpc-browser`.
For example.

```ts title="frontend/src/index.ts"
import { HttpClient } from 'tsrpc-browser'
import { serviceProto } from '. /shared/protocols/serviceProto'

let client = new HttpClient(serviceProto, {
  server: 'http://127.0.0.1:3000',
  logger: console,
})
```

:::note
Setting `logger: console` prints API calls to the console for easy debugging.
This is because TSRPC transfers are binary serialized, so you will see a mess of code in the network panel of the developer tools.
You can also omit this configuration in a production environment so that no one knows what you are doing üòÅ.
:::

### callApi

The client usage is almost identical across platforms: use `client.callApi()` to call the remote API as if you were calling an asynchronous function locally.
TSRPC is the ultimate experience for front-end access. There are code hints for the entire input and output, no need to even remember the URL, and no need for protocol documentation at all.

! [code writing experience](assets/code-hint.gif)

You don't have to worry about low-level errors caused by spelling mistakes, as TSRPC does double type checking at compile time and run time, so you can say goodbye to the painful experience of front- and back-side concatenation.

! [Code writing experience](assets/type-check.gif)

:::note
The return type of `callApi` is called `ApiReturn`, so it is often named `ret`.
:::

### Handling errors and responses

`callApi` is not always successful and some errors may occur, such as network errors, business errors, etc.
Many inexperienced programmers always fail to remember to handle errors, often leading to many ``stuck'' problems, such as

```js
showLoading();
let res = await fetch( ... );
hideLoading();
```

Forget about `catch` after `fetch`, once an exception is thrown by a network error, `hideLoading` will not be executed and Loading will never disappear and behave as "stuck".

Solution for #### TSRPC

1. All methods **do not throw exceptions**
   - so there is always **no need** for `catch()` or `try... .catch... `, avoiding the pitfall of novices always forgetting `catch`. 2.
2. all errors are **just handled in one place**
   - The success is determined by `ret.isSucc`, and the response `ret.res` is taken for success, and `ret.err` (with error type and details) is taken for failure.
3. cleverly make you **must do error detection** through the TypeScript type system
   - The TypeScript compiler will report an error if the code in the error handling section below is removed.

```ts title="frontend/src/index.ts"
window.onload = async function () {
  let ret = await client.callApi('Hello', {
    name: 'World',
  })

  // Error
  if (!ret.isSucc) {
    alert('Error: ' + ret.err.message)
    return
  }

  // Success
  alert('Success: ' + ret.res.reply)
}
```

## Test it

Start the local development server by executing the following commands in the `` frontend`'' and  ``backend`'' directories, respectively.

```shell
npm run dev
```

Once the service is up, open http://127.0.0.1:8080 with your browser and see the results

## Automatic type detection

TSRPC automatically type detects requests and responses, both at compile time and at run time, on both the client and server side.
So there is no need to care about type safety at all when writing API implementations.

**Example: request type not legal, error reported at compile time**

```ts
callApi('Hello', {
  name: 12345, // wrong type
})
```

Even if we skip TypeScript's compile-time checks, the TSRPC framework performs checks at runtime.

- The client performs a checksum first, blocking requests with illegal types locally.
- The server does a second check before executing the API to ensure that the API requests entering the execution phase must be of a legal type.

**Example: request type is not legal and is blocked by the framework**

```ts
callApi('Hello', {
  name: 12345,
} as any) // as any skips the TypeScript compile-time check

// request is intercepted, return type error message {isSucc: false, err: ... }
console.log(ret)
```

## Binary serialization

When you open Developer Tools in Chrome and go to the Network panel to grab the packet, you can see that the transfer looks like gibberish because the framework automatically serializes the transfer into a binary code. This is because the framework automatically serializes the transfer into binary encoding. This provides a smaller transfer size and better security than JSON.
Some plaintext is still visible because TSRPC does not encrypt or compress the packet body; developers can do their own encryption and compression of the binary encoding, which we describe in [later section](...). /flow/transfer-encryption.md).

## Backward Compatible Restful API

Binary serialization provides better transfer performance, but for compatibility reasons, TSRPC also supports traditional JSON methods such as XMLHttpRequest, fetch, etc.

The `jsonEnabled` option is enabled on the Server side.

```ts
const server = new HttpServer(serviceProto, {
    ...
    // JSON compatible call (POST)
    jsonEnabled: true,
    ...
});
```

The browser side can be called via JSON with

```ts
fetch('http://127.0.0.1:3000/Hello', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({
    name: 'World',
  }),
})
```

The call rules are

- URL is `Service root path/protocol path/interface name`
- Method is `POST` and body is a JSON string
- Header `Content-Type: application/json` needs to be included

`jsonEnabled` is disabled by default, not recommended for systems with high security requirements (raises the threshold for protocol cracking).

:::tip
JSON compatible mode, does not affect the automatic type detection work properly, it will not only automatically detect the defined fields, but also will automatically eliminate the undefined redundant fields, to ensure absolute type security.
:::
