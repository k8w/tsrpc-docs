---
sidebar_position: 3
id: serialization.html
---

# 二进制编码

TSRPC 并非基于 `JSON.stringify` 的结果二次编码，而是根据 TypeScript 类型定义直接编码到二进制，编码的时间和空间效率相当于 Protobuf。

如果你使用过 Protobuf，应该有印象：每个字段都要指定一个编码序号，你需要手动维护这些序号，来确保新旧协议的编码兼容。
TSRPC 不需要指定类似的编码序号，是如何做到二进制编码并且增减字段时还能保持新旧协议的编码兼容呢？

答案就是 TSRPC 中也存在类似的编码序号，但是是由命令行工具 **自动维护** 的。

例如你的一个 `interface` 有 3 个字段 `a`、`b`、`c`，它们的字段序号会被自动生成为 `1`、`2`、`3`。
假设你删除了 `b`，然后新增了一个 `d`，重新生成协议，字段序号会变成怎样呢？
事实上，新的字段结构 `a`、`c`、`d` 的编码序号会被生成为 `1`、`3`、`4`，自动与旧协议保持兼容。

这是因为当重新生成 ServiceProto 时，TSRPC 会检测目标位置的旧版协议，比较新旧协议然后自动完成兼容处理，确保一定不会出现编码序号的冲突。
我们把维护编码序号交给工具来完成，将你从手动管理中释放出来。

有兴趣可以了解另一个独立开源项目 [TSBuffer](https://github.com/k8w/tsbuffer) 。